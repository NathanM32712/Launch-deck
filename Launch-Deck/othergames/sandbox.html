<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Sandbox Town</title>
<style>
  html,body{margin:0;height:100%;background:#0e0e12;overflow:hidden}
  #wrap{width:100vw;height:100vh;display:grid;place-items:center}
  canvas{display:block;background:#111216;image-rendering:pixelated;image-rendering:crisp-edges}
  #hint{position:fixed;left:8px;bottom:8px;color:#cfd3dc;font:12px monospace;background:rgba(0,0,0,0.35);padding:6px;border-radius:6px}
  #titleBadge{position:fixed;right:8px;top:8px;color:#cfd3dc;font:12px monospace;background:rgba(0,0,0,0.35);padding:6px;border-radius:6px}
</style>
</head>
<body>
<div id="wrap"><canvas id="game" aria-label="Sandbox Town game"></canvas></div>
<div id="hint">WASD/Arrows move • Click/Space shoot • E enter/exit • R regenerate • P spawn car</div>
<div id="titleBadge">Sandbox Town</div>
<script>
(() => {
  // ---------- CONFIG ----------
  const VIEW_W = 256, VIEW_H = 144;
  const TILE = 32;
  const MAP_W = 80, MAP_H = 80;
  const MAP_PX_W = MAP_W * TILE, MAP_PX_H = MAP_H * TILE;
  const MAX_ZOMBIES = 120, LIGHT_CYCLE = 300;
  const CRASH_SPEED_THRESHOLD = 2.6, FIRE_DURATION = 300, FIRE_DAMAGE_PER_SEC = 18;

  // ---------- CANVAS ----------
  const screen = document.getElementById('game');
  const sctx = screen.getContext('2d', { alpha: false });
  const view = document.createElement('canvas'); view.width = VIEW_W; view.height = VIEW_H;
  const ctx = view.getContext('2d', { alpha: false });
  sctx.imageSmoothingEnabled = false; ctx.imageSmoothingEnabled = false;

  function computeScale() {
    const wrap = document.getElementById('wrap');
    const w = Math.max(320, wrap.clientWidth), h = Math.max(180, wrap.clientHeight);
    const sx = Math.floor(w / VIEW_W) || 1, sy = Math.floor(h / VIEW_H) || 1;
    return Math.max(1, Math.min(6, Math.min(sx, sy)));
  }
  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const scale = computeScale();
    const cssW = VIEW_W * scale, cssH = VIEW_H * scale;
    screen.style.width = cssW + 'px'; screen.style.height = cssH + 'px';
    screen._logicalScale = scale; screen._cssWidth = cssW; screen._cssHeight = cssH;
    screen.width = Math.floor(cssW * dpr); screen.height = Math.floor(cssH * dpr);
    sctx.setTransform(dpr,0,0,dpr,0,0);
    sctx.imageSmoothingEnabled = false;
  }
  window.addEventListener('resize', resize);
  resize();

  // ---------- INPUT ----------
  const keys = new Set();
  const mouse = { x:0, y:0, down:false, lastClientX:0, lastClientY:0 };
  window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (['arrowup','arrowdown','arrowleft','arrowright',' '].includes(k) || e.code === 'Space') e.preventDefault();
    keys.add(k);
  });
  window.addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));

  function clientToLogical(clientX, clientY) {
    const rect = screen.getBoundingClientRect();
    const cssToClientX = rect.width / screen._cssWidth;
    const cssToClientY = rect.height / screen._cssHeight;
    const cssX = (clientX - rect.left) / cssToClientX;
    const cssY = (clientY - rect.top) / cssToClientY;
    const logicalX = cssX / screen._logicalScale;
    const logicalY = cssY / screen._logicalScale;
    return { x: logicalX, y: logicalY };
  }

  screen.addEventListener('mousemove', e => {
    mouse.lastClientX = e.clientX; mouse.lastClientY = e.clientY;
    const p = clientToLogical(e.clientX, e.clientY);
    mouse.x = p.x; mouse.y = p.y;
  });
  screen.addEventListener('mousedown', e => {
    mouse.down = true; mouse.lastClientX = e.clientX; mouse.lastClientY = e.clientY;
    const p = clientToLogical(e.clientX, e.clientY); mouse.x = p.x; mouse.y = p.y;
  });
  window.addEventListener('mouseup', e => {
    mouse.down = false; mouse.lastClientX = e.clientX; mouse.lastClientY = e.clientY;
    const p = clientToLogical(e.clientX, e.clientY); mouse.x = p.x; mouse.y = p.y;
  });

  // ---------- UTILS ----------
  const rand = (a=1,b=0)=>Math.random()*(a-b)+b;
  const randi = (a,b)=> (Math.random()*(b-a)+a)|0;
  const lerp = (a,b,t)=>a+(b-a)*t;
  const dist2 = (ax,ay,bx,by)=> (ax-bx)*(ax-bx)+(ay-by)*(ay-by);
  const angleTo = (ax,ay,bx,by)=> Math.atan2(by-ay, bx-ax);
  const clamp = (v,mn,mx)=> Math.max(mn, Math.min(mx, v));
  function rotateVec(x,y,ang){ const c=Math.cos(ang), s=Math.sin(ang); return { x: x*c - y*s, y: x*s + y*c }; }

  // ---------- MAP ----------
  const map = new Array(MAP_H).fill(0).map(()=> new Array(MAP_W).fill(0));

  function carveRoadTileNoWrap(tx, ty, width=3) {
    for (let wy = -Math.floor(width/2); wy <= Math.floor((width-1)/2); wy++){
      for (let wx = -Math.floor(width/2); wx <= Math.floor((width-1)/2); wx++){
        const rx = tx + wx, ry = ty + wy;
        if (rx < 0 || rx >= MAP_W || ry < 0 || ry >= MAP_H) continue;
        if (map[ry][rx] === 2) continue;
        map[ry][rx] = 1;
      }
    }
  }

  function carvePathNoWrap(startTx, startTy, length, width=3, turniness=0.35, uphill=false, gapChance=0.02) {
    let tx = startTx, ty = startTy;
    let dir = Math.random()*Math.PI*2;
    for (let i=0;i<length;i++){
      if (Math.random() >= gapChance) carveRoadTileNoWrap(Math.round(tx), Math.round(ty), width);
      dir += rand(turniness, -turniness);
      tx += Math.cos(dir) * (1 + rand(0.2, -0.2));
      ty += Math.sin(dir) * (1 + rand(0.2, -0.2));
      if (uphill && Math.random() < 0.08) dir += Math.PI * (Math.random()<0.5 ? 0.6 : -0.6);
      tx = clamp(tx, 2, MAP_W-3);
      ty = clamp(ty, 2, MAP_H-3);
    }
  }

  function carveRoundabout(cx, cy, radius, width=3) {
    for (let a=0; a<360; a+=6) {
      const rx = Math.round(cx + Math.cos(a*Math.PI/180)*radius);
      const ry = Math.round(cy + Math.sin(a*Math.PI/180)*radius);
      if (rx < 1 || rx >= MAP_W-1 || ry < 1 || ry >= MAP_H-1) continue;
      carveRoadTileNoWrap(rx, ry, width);
    }
  }

  function generateMap() {
    for (let y=0;y<MAP_H;y++) for (let x=0;x<MAP_W;x++) map[y][x] = 0;

    const mountainCount = 4;
    for (let m=0;m<mountainCount;m++){
      const cx = randi(10, MAP_W-10), cy = randi(10, MAP_H-10);
      const r = randi(4, 12);
      for (let yy = cy - r; yy <= cy + r; yy++){
        for (let xx = cx - r; xx <= cx + r; xx++){
          if (xx < 0 || xx >= MAP_W || yy < 0 || yy >= MAP_H) continue;
          const dx = xx - cx, dy = yy - cy;
          if (dx*dx + dy*dy <= r*r) map[yy][xx] = 5;
        }
      }
    }

    const roadCount = 14;
    for (let r=0;r<roadCount;r++){
      const width = randi(2,4);
      const length = randi(Math.floor(MAP_W*0.6), Math.floor(MAP_W*1.2));
      let sx, sy;
      if (Math.random() < 0.5) {
        if (Math.random() < 0.5) { sx = Math.random()<0.5?1:MAP_W-2; sy = randi(6, MAP_H-7); }
        else { sy = Math.random()<0.5?1:MAP_H-2; sx = randi(6, MAP_W-7); }
      } else {
        sx = randi(8, MAP_W-9); sy = randi(8, MAP_H-9);
      }
      const uphill = Math.random() < 0.25;
      const gapChance = Math.random()*0.06;
      carvePathNoWrap(sx, sy, length, width, rand(0.45,0.18), uphill, gapChance);
      if (Math.random() < 0.35) {
        const cx = randi(10, MAP_W-10), cy = randi(10, MAP_H-10);
        const rr = randi(3,6);
        carveRoundabout(cx, cy, rr, width);
      }
    }

    for (let y=0;y<MAP_H;y++){
      for (let x=0;x<MAP_W;x++){
        if (map[y][x] === 1) {
          const nbs = [[1,0],[-1,0],[0,1],[0,-1]];
          for (let [dx,dy] of nbs) {
            const nx = x+dx, ny = y+dy;
            if (nx < 0 || nx >= MAP_W || ny < 0 || ny >= MAP_H) continue;
            if (map[ny][nx] === 0) map[ny][nx] = 3;
          }
        }
      }
    }

    for (let y=1;y<MAP_H-1;y++){
      for (let x=1;x<MAP_W-1;x++){
        if (map[y][x] === 1) {
          const horiz = (map[y][x-1]===1 || map[y][x+1]===1);
          const vert = (map[y-1][x]===1 || map[y+1][x]===1);
          if (horiz && vert && Math.random() < 0.6) map[y][x] = 4;
        }
      }
    }

    for (let i=0;i<MAP_W*MAP_H*0.12;i++){
      const bx = (Math.random()*MAP_W)|0, by = (Math.random()*MAP_H)|0;
      if (map[by][bx] === 0) map[by][bx] = 2;
    }
  }
  generateMap();

  // ---------- HELPERS ----------
  function tileAtPx(px,py) {
    const tx = Math.floor(px / TILE), ty = Math.floor(py / TILE);
    const mx = clamp(tx, 0, MAP_W-1), my = clamp(ty, 0, MAP_H-1);
    return map[my][mx];
  }
  function isRoadAt(px,py){ const t = tileAtPx(px,py); return t===1 || t===4; }
  function isSidewalkAt(px,py){ const t = tileAtPx(px,py); return t===3 || t===4; }
  function isSolidAt(px,py){ const t = tileAtPx(px,py); return t===2 || t===5; }

  function nearestTileCenter(x,y, matchFn, radiusTiles=12) {
    let best=null, bestD=Infinity;
    const cx = Math.floor(x/TILE), cy = Math.floor(y/TILE);
    for (let dy=-radiusTiles; dy<=radiusTiles; dy++){
      for (let dx=-radiusTiles; dx<=radiusTiles; dx++){
        const tx = cx + dx, ty = cy + dy;
        if (tx < 0 || tx >= MAP_W || ty < 0 || ty >= MAP_H) continue;
        if (matchFn(map[ty][tx])) {
          const c = { x: tx*TILE + TILE/2, y: ty*TILE + TILE/2 };
          const d = dist2(x,y,c.x,c.y);
          if (d < bestD) { bestD = d; best = c; }
        }
      }
    }
    return best;
  }
  const nearestRoadPoint = (x,y,r=12)=> nearestTileCenter(x,y, t=> t===1||t===4, r);
  const nearestSidewalkPoint = (x,y,r=12)=> nearestTileCenter(x,y, t=> t===3||t===4, r);

  // ---------- ENTITIES ----------
  // Vehicles slowed: reduced accel and maxV for all types
  const VEHICLE_TYPES = {
    sedan:   { kind:'car', accelF:0.012, accelR:0.010, maxV:1.3, drag:0.988, steerBase:0.030, w:36,h:20, color:'#7b8fa6' },
    sports:  { kind:'car', accelF:0.018, accelR:0.012, maxV:1.9, drag:0.988, steerBase:0.036, w:32,h:18, color:'#d96f6f' },
    truck:   { kind:'car', accelF:0.010, accelR:0.009, maxV:1.1, drag:0.990, steerBase:0.028, w:40,h:24, color:'#6f8a6f' },
    bike:    { kind:'bike', accelF:0.020, accelR:0.012, maxV:2.2, drag:0.989, steerBase:0.040, w:24,h:12, color:'#a7b7d0' }
  };
  const vehicles = [];
  function spawnVehicle(typeKey, x, y, owner=null) {
    const t = VEHICLE_TYPES[typeKey];
    vehicles.push({
      typeKey, kind: t.kind, x, y, vx:0, vy:0, angle: rand(Math.PI*2),
      width: t.w, height: t.h, accelF: t.accelF, accelR: t.accelR, maxV: t.maxV, drag: t.drag, steerBase: t.steerBase,
      color: t.color, owner, lastSteerDir:0, steerSwapTimer:0, driftTime:0, onFire:false, fireTimer:0, destroyed:false
    });
    return vehicles.length - 1;
  }

  const zombies = [];
  function randomSkinColor(){ return '#'+(Math.random()*0xFFFFFF|0).toString(16).padStart(6,'0'); }
  function spawnZombie(type="passive", groupId=null, near=null, forcedPos=null) {
    let zx, zy;
    if (forcedPos) { zx = forcedPos.x; zy = forcedPos.y; }
    else if (near) {
      const rp = nearestSidewalkPoint(near.x, near.y, 6) || nearestRoadPoint(near.x, near.y, 6);
      if (rp) { zx = rp.x + rand(12,-12); zy = rp.y + rand(12,-12); }
      else { zx = near.x + rand(24,-24); zy = near.y + rand(24,-24); }
    } else {
      const tx = (Math.random()*MAP_W)|0, ty = (Math.random()*MAP_H)|0;
      zx = tx*TILE + TILE/2 + rand(12,-12); zy = ty*TILE + TILE/2 + rand(12,-12);
    }
    zombies.push({
      x: zx, y: zy, vx:0, vy:0, speed: 0.45, skin: randomSkinColor(),
      state: "wander", provoked: false, type, groupId, timer: rand(200,60), cohesion: rand(0.055,0.025),
      fireCd: 0, inVehicle: null, enterTimer: 0, _dead: false, boardingTarget: null
    });
    return zombies.length - 1;
  }

  function spawnGroup(size=4) {
    const gid = Math.random().toString(36).slice(2,7);
    const tx = (Math.random()*MAP_W)|0, ty = (Math.random()*MAP_H)|0;
    const center = { x: tx*TILE + TILE/2 + rand(16,-16), y: ty*TILE + TILE/2 + rand(16,-16) };
    for (let i=0;i<size;i++) spawnZombie("group", gid, center);
  }

  function seedWorld() {
    zombies.length = 0; vehicles.length = 0;
    for (let i=0;i<MAX_ZOMBIES*0.6;i++){
      const r = Math.random();
      if (r < 0.55) spawnZombie("passive");
      else if (r < 0.8) spawnGroup((Math.random()*3|0)+2);
      else spawnZombie("armed");
    }
    const types = ['sedan','sports','truck','bike'];
    for (let i=0;i<28;i++){
      let attempts = 0;
      while (attempts < 600) {
        const tx = (Math.random()*MAP_W)|0, ty = (Math.random()*MAP_H)|0;
        if (map[ty][tx] === 1 || map[ty][tx] === 4) {
          const c = { x: tx*TILE + TILE/2 + rand(12,-12), y: ty*TILE + TILE/2 + rand(12,-12) };
          const t = types[(Math.random()*types.length)|0];
          const vid = spawnVehicle(t, c.x, c.y, null);
          if (Math.random() < 0.45 && zombies.length > 0) {
            const zi = (Math.random()*zombies.length)|0;
            vehicles[vid].owner = zi;
            zombies[zi].inVehicle = vid;
            zombies[zi].x = vehicles[vid].x; zombies[zi].y = vehicles[vid].y;
          }
          break;
        }
        attempts++;
      }
    }
  }
  seedWorld();

  // ---------- STOPLIGHTS ----------
  const stoplights = [];
  function placeStoplights() {
    stoplights.length = 0;
    for (let ty=0; ty<MAP_H; ty++){
      for (let tx=0; tx<MAP_W; tx++){
        if (map[ty][tx] === 4) {
          stoplights.push({ x: tx*TILE + TILE/2, y: ty*TILE + TILE/2, timer: (Math.random()*LIGHT_CYCLE*2)|0, state: (Math.random()<0.5?'green':'red') });
        }
      }
    }
  }
  placeStoplights();
  function updateLights() {
    for (let L of stoplights) {
      L.timer = (L.timer + 1) % (LIGHT_CYCLE*2);
      L.state = (L.timer < LIGHT_CYCLE) ? 'green' : 'red';
    }
  }

  // ---------- PROJECTILES ----------
  const bullets = [], hostileBullets = [];

  // When player shoots, nearby zombies become provoked (player "hit" or "attacked")
  function provokeNearbyZombies(x,y, radius = TILE*2.2) {
    const r2 = radius*radius;
    for (let z of zombies) {
      if (z._dead) continue;
      const d2 = (z.x - x)*(z.x - x) + (z.y - y)*(z.y - y);
      if (d2 <= r2) z.provoked = true;
    }
  }

  function shoot() {
    const canShoot = player.onFoot || (ride !== null);
    if (!canShoot) return;
    let ox = player.x, oy = player.y, aimAngle;
    if (player.onFoot) {
      aimAngle = angleTo(player.x, player.y, camX + mouse.x, camY + mouse.y);
      ox = player.x + Math.cos(aimAngle) * 12;
      oy = player.y + Math.sin(aimAngle) * 12;
    } else {
      const v = vehicles[ride];
      aimAngle = angleTo(v.x, v.y, camX + mouse.x, camY + mouse.y);
      const frontOffset = Math.max(v.width, v.height) * 0.6;
      ox = v.x + Math.cos(aimAngle) * frontOffset;
      oy = v.y + Math.sin(aimAngle) * frontOffset;
      player.x = v.x; player.y = v.y;
    }
    const speed = 3.2;
    bullets.push({ x: ox, y: oy, vx: Math.cos(aimAngle)*speed, vy: Math.sin(aimAngle)*speed, life: 60 });
    // provoke zombies near the shot origin (player attacked)
    provokeNearbyZombies(ox, oy, TILE*2.2);
  }
  screen.addEventListener('click', shoot);
  window.addEventListener('keydown', e => { if (e.code === 'Space') shoot(); });

  // ---------- VEHICLE HIT / COLLISIONS ----------
  function vehicleHitByBullet(b) {
    for (let i=0;i<vehicles.length;i++){
      const v = vehicles[i];
      if (v.destroyed) continue;
      const dx = b.x - v.x, dy = b.y - v.y;
      if (Math.abs(dx) < v.width && Math.abs(dy) < v.height) return i;
    }
    return -1;
  }

  function explodeVehicle(vid) {
    const v = vehicles[vid];
    if (!v || v.destroyed) return;
    v.destroyed = true;
    v.onFire = false;
    v.fireTimer = 0;
    for (let p=0;p<18;p++){
      particles.push({
        x: v.x + rand(12,-12), y: v.y + rand(12,-12),
        vx: Math.cos(Math.random()*Math.PI*2) * rand(1.6,0.4),
        vy: Math.sin(Math.random()*Math.PI*2) * rand(1.6,0.4),
        life: 40 + Math.random()*30, color: (Math.random()<0.6? '#ff9a3c' : '#ff3c3c')
      });
    }
    particles.push({ x:v.x, y:v.y, vx:0, vy:0, life: 40, color:'#ffd35a', big:true });
  }

  function checkVehicleCollisions() {
    for (let i=0;i<vehicles.length;i++){
      const v = vehicles[i];
      if (v.destroyed) continue;
      const samplePoints = [
        {x: v.x + Math.cos(v.angle)*v.width*0.5, y: v.y + Math.sin(v.angle)*v.width*0.5},
        {x: v.x - Math.cos(v.angle)*v.width*0.5, y: v.y - Math.sin(v.angle)*v.width*0.5},
        {x: v.x + Math.cos(v.angle+Math.PI/2)*v.height*0.5, y: v.y + Math.sin(v.angle+Math.PI/2)*v.height*0.5}
      ];
      let hitSolid = false;
      for (let p of samplePoints) {
        if (isSolidAt(p.x, p.y)) { hitSolid = true; break; }
      }
      let hitVehicleIndex = -1;
      for (let j=0;j<vehicles.length;j++){
        if (i===j) continue;
        const o = vehicles[j];
        if (o.destroyed) continue;
        const d2 = (o.x - v.x)*(o.x - v.x) + (o.y - v.y)*(o.y - v.y);
        if (d2 < ((v.width + o.width) * 0.5)*((v.width + o.width) * 0.5)) { hitVehicleIndex = j; break; }
      }
      if (hitSolid || hitVehicleIndex >= 0) {
        const speed = Math.hypot(v.vx, v.vy);
        if (speed >= CRASH_SPEED_THRESHOLD) {
          explodeVehicle(i);
          if (v.owner !== null) {
            const zi = v.owner;
            if (zombies[zi]) zombies[zi]._dead = true;
            v.owner = null;
          }
          if (ride === i) {
            player.hp = 0;
            player.onFoot = true;
            ride = null;
          }
        } else if (speed > 0.6) {
          if (!v.onFire) {
            v.onFire = true;
            v.fireTimer = FIRE_DURATION;
          }
          v.vx *= -0.3; v.vy *= -0.3;
        } else {
          v.vx *= -0.2; v.vy *= -0.2;
        }
      }
    }
  }

  // ---------- PARTICLES ----------
  const particles = [];
  function updateParticles(dt) {
    for (let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.x += p.vx * dt * 4; p.y += p.vy * dt * 4;
      p.vx *= 0.98; p.vy *= 0.98;
      p.life -= dt;
      if (p.life <= 0) particles.splice(i,1);
    }
  }

  // ---------- BOARDING ----------
  function tryBoardVehicle(zi) {
    const z = zombies[zi];
    if (z.inVehicle !== null || z._dead) return;
    let best = -1, bestD = 24*24;
    for (let vi=0; vi<vehicles.length; vi++){
      const v = vehicles[vi];
      if (v.owner !== null || v.destroyed) continue;
      const speed = Math.hypot(v.vx, v.vy);
      if (speed > 1.6) continue;
      const d = (v.x - z.x)*(v.x - z.x) + (v.y - z.y)*(v.y - z.y);
      if (d < bestD) { bestD = d; best = vi; }
    }
    if (best >= 0) {
      if (!z.enterTimer) z.enterTimer = 40 + Math.random()*30;
      z.enterTimer -= 1;
      const v = vehicles[best];
      const a = angleTo(z.x, z.y, v.x, v.y);
      z.vx = Math.cos(a) * z.speed * 0.9;
      z.vy = Math.sin(a) * z.speed * 0.9;
      if (z.enterTimer <= 0 && (v.x - z.x)*(v.x - z.x) + (v.y - z.y)*(v.y - z.y) < 14*14) {
        v.owner = zi;
        z.inVehicle = best;
        z.enterTimer = 0;
        z.x = v.x; z.y = v.y;
      }
    } else {
      z.enterTimer = 0;
    }
  }

  // ---------- PLAYER ----------
  // Player slowed: reduced speed
  const player = { x: MAP_PX_W/2, y: MAP_PX_H/2, vx:0, vy:0, speed:0.85, facing:0, onFoot:true, hp:100, iFrame:0 };
  let ride = null;

  function reset() {
    player.x = MAP_PX_W/2; player.y = MAP_PX_H/2; player.vx=0; player.vy=0; player.onFoot=true; player.hp=100; player.iFrame=0;
    ride = null; bullets.length = 0; hostileBullets.length = 0; particles.length = 0;
    generateMap(); placeStoplights(); seedWorld();
  }
  window.addEventListener('keydown', e => { if (e.key.toLowerCase() === 'r') reset(); });

  window.addEventListener('keydown', e => {
    if (e.key.toLowerCase() === 'e') {
      if (ride === null) {
        let best = -1, bestD = 26*26;
        for (let i=0;i<vehicles.length;i++){
          const v = vehicles[i];
          const d = (player.x - v.x)*(player.x - v.x) + (player.y - v.y)*(player.y - v.y);
          if (d < bestD) { bestD = d; best = i; }
        }
        if (best >= 0) {
          if (vehicles[best].owner !== null) {
            const zi = vehicles[best].owner;
            if (zombies[zi]) zombies[zi]._dead = true;
            vehicles[best].owner = null;
          }
          ride = best;
          player.onFoot = false;
          player.x = vehicles[ride].x; player.y = vehicles[ride].y;
        }
      } else {
        const v = vehicles[ride];
        player.x = v.x + Math.cos(v.angle)*12;
        player.y = v.y + Math.sin(v.angle)*12;
        player.vx = 0; player.vy = 0;
        player.onFoot = true;
        ride = null;
      }
    }
  });

  window.addEventListener('keydown', e => {
    if (e.key.toLowerCase() === 'p') {
      const rp = nearestRoadPoint(player.x, player.y, 12) || { x: player.x + 40, y: player.y };
      spawnVehicle('sports', rp.x + rand(12,-12), rp.y + rand(12,-12), null);
    }
  });

  // ---------- MAIN LOOP ----------
  let camX = MAP_PX_W/2 - VIEW_W/2, camY = MAP_PX_H/2 - VIEW_H/2;
  let last = performance.now();

  function tick(now) {
    const dt = Math.min(32, now - last) / 16.666;
    last = now;

    updateLights();

    // player movement
    if (player.onFoot) {
      const up = keys.has('w') || keys.has('arrowup');
      const dn = keys.has('s') || keys.has('arrowdown');
      const lf = keys.has('a') || keys.has('arrowleft');
      const rt = keys.has('d') || keys.has('arrowright');
      let ax=0, ay=0;
      if (up) ay -= 1; if (dn) ay += 1; if (lf) ax -= 1; if (rt) ax += 1;
      const mag = Math.hypot(ax, ay); if (mag > 0) { ax /= mag; ay /= mag; }
      player.vx = lerp(player.vx, ax * player.speed, 0.4);
      player.vy = lerp(player.vy, ay * player.speed, 0.4);
      let nx = player.x + player.vx * dt * 3, ny = player.y + player.vy * dt * 3;
      if (tileAtPx(nx, ny) !== 2 && tileAtPx(nx, ny) !== 5) { player.x = nx; player.y = ny; } else { player.vx = 0; player.vy = 0; }
      player.facing = angleTo(player.x, player.y, camX + mouse.x, camY + mouse.y);
    } else if (ride !== null) {
      const v = vehicles[ride];
      if (!v || v.destroyed) { ride = null; player.onFoot = true; }
      else driveVehicle(v, dt);
    }

    // hostile bullets
    if (player.iFrame > 0) player.iFrame -= dt;
    for (let i=hostileBullets.length-1;i>=0;i--){
      const b = hostileBullets[i];
      b.x += b.vx * dt * 4; b.y += b.vy * dt * 4; b.life -= dt;
      if (b.life <= 0) { hostileBullets.splice(i,1); continue; }
      const tx = ride === null ? player.x : vehicles[ride].x;
      const ty = ride === null ? player.y : vehicles[ride].y;
      const rad2 = ride === null ? 9*9 : 12*12;
      if (dist2(b.x,b.y,tx,ty) < rad2 && player.iFrame <= 0) {
        player.hp = Math.max(0, player.hp - 10);
        player.iFrame = 20;
        hostileBullets.splice(i,1);
      }
    }

    // player bullets
    for (let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      b.x += b.vx * dt * 4; b.y += b.vy * dt * 4; b.life -= dt;
      if (b.life <= 0) { bullets.splice(i,1); continue; }
      const vid = vehicleHitByBullet(b);
      if (vid >= 0) {
        const v = vehicles[vid];
        if (v.owner !== null) {
          const zi = v.owner;
          if (zombies[zi]) zombies[zi]._dead = true;
          v.owner = null;
          bullets.splice(i,1);
          // provoke zombies near the vehicle hit
          provokeNearbyZombies(v.x, v.y, TILE*2.2);
          continue;
        } else {
          bullets.splice(i,1);
          continue;
        }
      }
      // bullets that pass near zombies provoke them; if they hit, they kill as before
      for (let j=zombies.length-1;j>=0;j--){
        const z = zombies[j];
        if (z._dead) continue;
        if (z.inVehicle !== null) continue;
        if (dist2(b.x,b.y,z.x,z.y) < 10*10) {
          // hit: kill and provoke nearby survivors
          z._dead = true;
          provokeNearbyZombies(z.x, z.y, TILE*2.2);
          bullets.splice(i,1);
          break;
        } else {
          // if bullet passes close (but not kill), provoke
          if (dist2(b.x,b.y,z.x,z.y) < (TILE*0.9)*(TILE*0.9)) z.provoked = true;
        }
      }
    }

    for (let i=zombies.length-1;i>=0;i--) if (zombies[i]._dead) zombies.splice(i,1);

    // vehicles update
    for (let vi=0; vi<vehicles.length; vi++){
      const v = vehicles[vi];
      if (v.destroyed) continue;
      if (v.owner !== null) {
        const zi = v.owner;
        const z = zombies[zi];
        if (!z || z._dead) { v.owner = null; continue; }
        const tx = ride === null ? player.x : vehicles[ride].x;
        const ty = ride === null ? player.y : vehicles[ride].y;
        aiDriveVehicle(v, tx, ty, dt);
        z.x = v.x; z.y = v.y; z.inVehicle = vi;
        if (v.onFire) {
          v.fireTimer -= dt;
          if (v.fireTimer <= 0) v.onFire = false;
        }
      } else {
        v.x += v.vx * dt * 4; v.y += v.vy * dt * 4;
        v.vx *= 0.995; v.vy *= 0.995;
        if (v.onFire) {
          v.fireTimer -= dt;
          if (v.fireTimer <= 0) v.onFire = false;
        }
      }
    }

    // collisions
    checkVehicleCollisions();

    // zombies AI: passive unless provoked
    const targetX = ride === null ? player.x : vehicles[ride].x;
    const targetY = ride === null ? player.y : vehicles[ride].y;
    for (let zi=0; zi<zombies.length; zi++){
      const z = zombies[zi];
      if (z.inVehicle !== null) continue;
      tryBoardVehicle(zi);
      if (z.enterTimer > 0) {
        const nx = z.x + z.vx * dt * 3, ny = z.y + z.vy * dt * 3;
        if (tileAtPx(nx, ny) !== 2 && tileAtPx(nx, ny) !== 5) { z.x = nx; z.y = ny; } else { z.vx *= -0.4; z.vy *= -0.4; }
        continue;
      }

      // NEW: only act if provoked
      if (z.provoked) {
        const rp = nearestSidewalkPoint(targetX, targetY, 12) || nearestRoadPoint(targetX, targetY, 12);
        const tx = rp ? rp.x : targetX;
        const ty = rp ? rp.y : targetY;
        const a = angleTo(z.x, z.y, tx, ty);
        z.vx = Math.cos(a) * z.speed; z.vy = Math.sin(a) * z.speed;
        if (z.type === "armed") { z.fireCd -= dt; if (z.fireCd <= 0) { hostileBullets.push({ x: z.x, y: z.y, vx: Math.cos(a)*2.6, vy: Math.sin(a)*2.6, life: 90 }); z.fireCd = rand(80,40); } }
      } else {
        // passive wandering
        z.timer -= dt;
        if (z.timer <= 0) {
          z.timer = rand(200,60);
          const rp = nearestSidewalkPoint(z.x, z.y, 6);
          if (rp) {
            const a = angleTo(z.x, z.y, rp.x + rand(12,-12), rp.y + rand(12,-12));
            z.vx = Math.cos(a) * z.speed*0.6; z.vy = Math.sin(a) * z.speed*0.6;
          } else {
            const a = rand(Math.PI*2);
            z.vx = Math.cos(a) * z.speed*0.6; z.vy = Math.sin(a) * z.speed*0.6;
          }
        }
      }

      let nx = z.x + z.vx * dt * 3, ny = z.y + z.vy * dt * 3;
      if (isSidewalkAt(nx, ny)) {
        z.x = nx; z.y = ny;
      } else {
        const rp = nearestSidewalkPoint(z.x, z.y, 8);
        if (rp) {
          const a = angleTo(z.x, z.y, rp.x, rp.y);
          z.vx = Math.cos(a) * z.speed*0.6; z.vy = Math.sin(a) * z.speed*0.6;
          z.x += z.vx * dt * 3; z.y += z.vy * dt * 3;
        } else {
          z.x = nx; z.y = ny;
        }
      }
    }

    while (zombies.length < MAX_ZOMBIES) {
      const r = Math.random();
      if (r < 0.6) spawnZombie("passive");
      else if (r < 0.85) spawnGroup((Math.random()*3|0)+3);
      else spawnZombie("armed");
    }

    updateParticles(dt);

    for (let v of vehicles) {
      if (v.onFire) {
        if (ride !== null && vehicles[ride] === v) {
          const dmg = FIRE_DAMAGE_PER_SEC * (dt/60);
          player.hp = Math.max(0, player.hp - dmg);
          if (player.hp <= 0) { player.onFoot = true; ride = null; }
        }
        if (v.owner !== null) {
          const zi = v.owner;
          if (zombies[zi]) {
            if (v.fireTimer < 80) zombies[zi]._dead = true;
          }
        }
      }
    }

    const fx = ride === null ? player.x : vehicles[ride].x;
    const fy = ride === null ? player.y : vehicles[ride].y;
    camX = lerp(camX, fx - VIEW_W/2, 0.12);
    camY = lerp(camY, fy - VIEW_H/2, 0.12);

    render();

    requestAnimationFrame(tick);
  }

  // ---------- DRIVE PHYSICS & AI ----------
  function driveVehicle(v, dt) {
    const up = keys.has('w') || keys.has('arrowup');
    const dn = keys.has('s') || keys.has('arrowdown');
    const lf = keys.has('a') || keys.has('arrowleft');
    const rt = keys.has('d') || keys.has('arrowright');

    const accel = (up ? v.accelF : 0) - (dn ? v.accelR : 0);
    v.vx += Math.cos(v.angle) * accel;
    v.vy += Math.sin(v.angle) * accel;

    const speed = Math.hypot(v.vx, v.vy);
    const steerLimit = v.steerBase * (1 / (1 + speed*0.7));
    let steerDir = (lf ? -1 : 0) + (rt ? 1 : 0);
    const steer = steerDir * steerLimit;

    v.angle += steer * 1.6;

    const baseVelRotate = steer * 0.9;
    let velRotate = clamp(baseVelRotate, -0.18, 0.18);
    if (speed < 0.25) velRotate *= 1.8;
    const r = rotateVec(v.vx, v.vy, velRotate);
    v.vx = r.x; v.vy = r.y;

    if (steerDir !== 0) {
      if (v.lastSteerDir === 0) { v.lastSteerDir = steerDir; v.steerSwapTimer = 0; }
      else if (steerDir !== v.lastSteerDir) {
        if (v.steerSwapTimer < 12) v.driftTime = v.kind==='bike' ? 10 : 16;
        v.lastSteerDir = steerDir; v.steerSwapTimer = 0;
      }
    } else { v.lastSteerDir = 0; }
    v.steerSwapTimer += 1;

    if (v.driftTime > 0) {
      const sideAngle = v.angle + (v.lastSteerDir>0 ? Math.PI/2 : -Math.PI/2);
      const lateral = 0.018 * (speed*0.5 + 0.2);
      v.vx += Math.cos(sideAngle) * lateral;
      v.vy += Math.sin(sideAngle) * lateral;
      v.driftTime -= 1;
    }

    v.vx *= v.drag; v.vy *= v.drag;
    const s = Math.hypot(v.vx, v.vy);
    if (s > v.maxV) { v.vx *= v.maxV/s; v.vy *= v.maxV/s; }

    v.x += v.vx * dt * 4;
    v.y += v.vy * dt * 4;
  }

  function aiDriveVehicle(v, targetX, targetY, dt) {
    let nearestLight = null, nd = Infinity;
    for (let L of stoplights) {
      const d = dist2(v.x, v.y, L.x, L.y);
      if (d < nd) { nd = d; nearestLight = L; }
    }
    const rpTarget = nearestRoadPoint(targetX, targetY, 14) || { x: targetX, y: targetY };
    const desired = angleTo(v.x, v.y, rpTarget.x, rpTarget.y);
    let diff = desired - v.angle;
    while (diff > Math.PI) diff -= Math.PI*2;
    while (diff < -Math.PI) diff += Math.PI*2;
    const steerInput = clamp(diff * 1.5, -1, 1);
    const steerLimit = v.steerBase * (1 / (1 + Math.hypot(v.vx, v.vy)*0.7));
    const steer = steerInput * steerLimit;
    v.angle += steer * 1.1;
    v.vx += Math.cos(v.angle) * (v.accelF * 0.6);
    v.vy += Math.sin(v.angle) * (v.accelF * 0.6);
    for (let other of vehicles) {
      if (other === v) continue;
      const d2 = (other.x - v.x)*(other.x - v.x) + (other.y - v.y)*(other.y - v.y);
      if (d2 < (28*28)) {
        const away = Math.atan2(v.y - other.y, v.x - other.x);
        v.vx += Math.cos(away) * 0.035;
        v.vy += Math.sin(away) * 0.035;
        v.vx *= 0.995; v.vy *= 0.995;
      }
    }
    const r = rotateVec(v.vx, v.vy, clamp(0.6 * (v.steerBase || 0.03), -0.06, 0.06));
    v.vx = r.x; v.vy = r.y;
    v.vx *= v.drag; v.vy *= v.drag;
    const s = Math.hypot(v.vx, v.vy);
    if (s > v.maxV) { v.vx *= v.maxV/s; v.vy *= v.maxV/s; }
    v.x += v.vx * dt * 4;
    v.y += v.vy * dt * 4;
  }

  // ---------- RENDER ----------
  function render() {
    // draw world to view canvas
    ctx.fillStyle = '#0b0f14'; ctx.fillRect(0,0,VIEW_W,VIEW_H);

    // draw tiles (simple)
    const startTx = Math.floor(camX / TILE) - 2;
    const startTy = Math.floor(camY / TILE) - 2;
    const endTx = Math.floor((camX + VIEW_W) / TILE) + 2;
    const endTy = Math.floor((camY + VIEW_H) / TILE) + 2;
    for (let ty = startTy; ty <= endTy; ty++){
      for (let tx = startTx; tx <= endTx; tx++){
        if (tx < 0 || tx >= MAP_W || ty < 0 || ty >= MAP_H) continue;
        const tile = map[ty][tx];
        const px = tx * TILE - camX;
        const py = ty * TILE - camY;
        if (tile === 0) { ctx.fillStyle = '#1b2b1e'; ctx.fillRect(px,py,TILE,TILE); }
        else if (tile === 1) { ctx.fillStyle = '#2c2e33'; ctx.fillRect(px,py,TILE,TILE); ctx.fillStyle = '#3c3f46'; ctx.fillRect(px,py+TILE/2-Math.max(1,Math.floor(TILE*0.03)),TILE,Math.max(2,Math.floor(TILE*0.06))); }
        else if (tile === 2) { ctx.fillStyle = '#3a2f3f'; ctx.fillRect(px,py,TILE,TILE); }
        else if (tile === 3) { ctx.fillStyle = '#6b6b6b'; ctx.fillRect(px,py,TILE,TILE); }
        else if (tile === 4) { ctx.fillStyle = '#2c2e33'; ctx.fillRect(px,py,TILE,TILE); ctx.fillStyle = '#fff'; ctx.fillRect(px+Math.floor(TILE*0.09),py+Math.floor(TILE*0.09),TILE-Math.floor(TILE*0.18),Math.max(2,Math.floor(TILE*0.06))); }
        else if (tile === 5) { ctx.fillStyle = '#2b3b2b'; ctx.fillRect(px,py,TILE,TILE); }
      }
    }

    // vehicles
    for (let v of vehicles) {
      if (v.destroyed) continue;
      const sx = v.x - camX, sy = v.y - camY;
      ctx.save(); ctx.translate(sx, sy); ctx.rotate(v.angle);
      ctx.fillStyle = v.color || '#7b8fa6';
      ctx.fillRect(-v.width/2, -v.height/2, v.width, v.height);
      ctx.restore();
      if (v.onFire) {
        ctx.fillStyle = 'rgba(255,120,40,0.85)';
        ctx.beginPath(); ctx.ellipse(sx, sy - 6, v.width*0.6, v.height*0.6, 0, 0, Math.PI*2); ctx.fill();
      }
    }

    // particles
    for (let p of particles) {
      const px = p.x - camX, py = p.y - camY;
      if (p.big) { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(px,py,8,0,Math.PI*2); ctx.fill(); }
      else { ctx.fillStyle = p.color; ctx.fillRect(px-1,py-1,2,2); }
    }

    // zombies
    for (let z of zombies) {
      if (z.inVehicle !== null) continue;
      const zx = z.x - camX, zy = z.y - camY;
      ctx.fillStyle = z.skin; ctx.fillRect(zx-6, zy-6, 12, 12);
      // subtle indicator if provoked
      if (z.provoked) {
        ctx.strokeStyle = 'rgba(255,80,80,0.6)'; ctx.strokeRect(zx-8, zy-8, 16, 16);
      }
    }

    // player
    const px = player.x - camX, py = player.y - camY;
    if (player.onFoot) {
      ctx.save(); ctx.translate(px, py); ctx.rotate(player.facing);
      ctx.fillStyle = '#e3d5b8'; ctx.fillRect(-6, -6, 12, 12);
      ctx.restore();
    } else if (ride !== null) {
      // small indicator at center
      ctx.fillStyle = '#e3d5b8'; ctx.fillRect(VIEW_W/2-4, VIEW_H/2-12, 8, 12);
    }

    // bullets
    ctx.fillStyle = '#ffd35a';
    for (let b of bullets) {
      const bx = b.x - camX, by = b.y - camY;
      ctx.fillRect(bx -1, by -1, 2, 2);
    }
    ctx.fillStyle = '#ff7b7b';
    for (let b of hostileBullets) {
      const bx = b.x - camX, by = b.y - camY;
      ctx.fillRect(bx -1, by -1, 2, 2);
    }

    // copy view to screen
    sctx.clearRect(0,0,screen.width,screen.height);
    sctx.drawImage(view, 0, 0, VIEW_W, VIEW_H, 0, 0, screen._cssWidth, screen._cssHeight);
  }

  // ---------- INIT ----------
  function init() {
    placeStoplights();
    seedWorld();
    camX = MAP_PX_W/2 - VIEW_W/2; camY = MAP_PX_H/2 - VIEW_H/2;
    last = performance.now();
    requestAnimationFrame(tick);
  }
  init();

})();
</script>
</body>
</html>